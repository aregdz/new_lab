### Модель многопользовательского доступа: MVCC

**Дата:** 2025-10-27  
**Семестр:** 4 курс 1 полугодие – 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Джараян Арег Александрович

### Цель работы
Изучить принципы многоверсионного управления конкурентным доступом (MVCC) в PostgreSQL. Получить практические навыки наблюдения за работой MVCC, анализа версий строк, снимков данных и уровней изоляции транзакций. Освоить использование расширений и системных представлений для исследования внутренней структуры данных.

### Теоретическая часть (кратко):
MVCC (Multiversion Concurrency Control) позволяет нескольким транзакциям работать с одними данными одновременно, минимизируя блокировки. Каждая транзакция видит согласованный «снимок» данных на момент своего начала. При изменении строки создаётся новая версия, старая хранится до очистки. Системные поля: xmin — транзакция, создавшая версию, xmax — транзакция, удалившая или заблокировавшая версию, ctid — физическое расположение строки. Уровни изоляции: Read Committed — видны только зафиксированные данные, Repeatable Read — предотвращает неповторяемое чтение, Serializable — полностью исключает аномалии. Снимок данных определяет, какие версии строк видимы транзакции.

### Модуль 1: Уровни изоляции и аномалии
## 1. Read Committed vs Удаление:
Создал таблицу iso_test (id INT, data TEXT) и вставил одну строку.
В сеансе 1 начал транзакцию с уровнем READ COMMITTED и выполнил SELECT * FROM
iso_test;.
В сеансе 2 удалил строку и зафиксировал изменения (DELETE ...; COMMIT;).
В сеансе 1 выполнил тот же SELECT повторно. 
```sql
-- Сеанс 1
CREATE DATABASE lab03_db;
\c lab03_db
CREATE TABLE iso_test(id INT, data TEXT);
INSERT INTO iso_test VALUES (1,'row1');

BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT * FROM iso_test;
```
```sql
-- Сеанс 2
\c lab03_db
DELETE FROM iso_test WHERE id=1;
COMMIT;
```
```sql
-- Сеанс 1
SELECT * FROM iso_test;
COMMIT;
```
Фрагмент вывода: 
```text
CREATE DATABASE
You are now connected to database "lab03_db" as user "student".

CREATE TABLE

INSERT 0 1

BEGIN

 id | data 
----+------
  1 | row1
(1 row)
```
```text
You are now connected to database "lab03_db" as user "student".

DELETE 1

WARNING:  there is no transaction in progress
COMMIT

```
```text
 id | data 
----+------
  1 | row1
(1 row)

COMMIT
```
**Вывод:**  cоздалась таблица, добавили данные и начали транзакцию. Пока видим одну строку. Псоле удаление всех данные из таблицы и подтверждение изменений. После а уровне `READ COMMITTED` мы увидим, что строки исчезли, потому что эта транзакция видит изменения, подтвержденные другими.


## 2. Repeatable Read vs Удаление:
Повторил предыдущий эксперимент, но в сеансе 1 начал транзакцию с BEGIN
ISOLATION LEVEL REPEATABLE READ;.
Объяснил разницу в результатах между двумя уровнями изоляции.
## 3. Создание таблицы в транзакции:
В сеансе 1 начните транзакцию и создайте новую таблицу new_table, вставьте в нее строку.
Не фиксируйте.
В сеансе 2 выполните SELECT * FROM new_table;. Что произойдет?
Зафиксируйте транзакцию в сеансе 1. Повторите запрос в сеансе 2.
Повторите процесс, но вместо фиксации откатите транзакцию в сеансе 1. Что изменилось?
## 4. Блокировка DDL:
В сеансе 1 начните транзакцию и выполните SELECT * FROM iso_test; (даже если
таблица пуста).
Попытайтесь в сеансе 2 выполнить DROP TABLE iso_test;. Получится ли? Объясните,
почему.
