### Модель многопользовательского доступа: MVCC

**Дата:** 2025-10-27  
**Семестр:** 4 курс 1 полугодие – 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Джараян Арег Александрович

### Цель работы
Изучить принципы многоверсионного управления конкурентным доступом (MVCC) в PostgreSQL. Получить практические навыки наблюдения за работой MVCC, анализа версий строк, снимков данных и уровней изоляции транзакций. Освоить использование расширений и системных представлений для исследования внутренней структуры данных.

### Теоретическая часть (кратко):
MVCC (Multiversion Concurrency Control) позволяет нескольким транзакциям работать с одними данными одновременно, минимизируя блокировки. Каждая транзакция видит согласованный «снимок» данных на момент своего начала. При изменении строки создаётся новая версия, старая хранится до очистки. Системные поля: xmin — транзакция, создавшая версию, xmax — транзакция, удалившая или заблокировавшая версию, ctid — физическое расположение строки. Уровни изоляции: Read Committed — видны только зафиксированные данные, Repeatable Read — предотвращает неповторяемое чтение, Serializable — полностью исключает аномалии. Снимок данных определяет, какие версии строк видимы транзакции.

### Модуль 1: Уровни изоляции и аномалии
## 1. Read Committed vs Удаление:
Создайте таблицу iso_test (id INT, data TEXT) и вставьте одну строку.
В сеансе 1 начните транзакцию с уровнем READ COMMITTED и выполните SELECT * FROM
iso_test;.
В сеансе 2 удалите строку и зафиксируйте изменения (DELETE ...; COMMIT;).
В сеансе 1 выполните тот же SELECT повторно. Сколько строк увидите? Завершите
транзакцию в сеансе 1.
## 2. Repeatable Read vs Удаление:
Повторите предыдущий эксперимент, но в сеансе 1 начните транзакцию с BEGIN
ISOLATION LEVEL REPEATABLE READ;.
Объясните разницу в результатах между двумя уровнями изоляции.
## 3. Создание таблицы в транзакции:
В сеансе 1 начните транзакцию и создайте новую таблицу new_table, вставьте в нее строку.
Не фиксируйте.
В сеансе 2 выполните SELECT * FROM new_table;. Что произойдет?
Зафиксируйте транзакцию в сеансе 1. Повторите запрос в сеансе 2.
Повторите процесс, но вместо фиксации откатите транзакцию в сеансе 1. Что изменилось?
## 4. Блокировка DDL:
В сеансе 1 начните транзакцию и выполните SELECT * FROM iso_test; (даже если
таблица пуста).
Попытайтесь в сеансе 2 выполнить DROP TABLE iso_test;. Получится ли? Объясните,
почему.
